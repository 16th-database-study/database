## ORDER BY 처리
레코드를 정렬하기 위해 인덱스를 고를 수도 있지만 인덱스를 통해 모든 처리하는 것은 현실적으로 불가능하다. 그러한 이유를 정리해보면 아래와 같다.
- 정렬 기준이 너무 많아 요건 별로 모든 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

MySQL에서는 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아 사용하는데, 이 메모리 공간을 소트 버퍼라 한다.

정렬 과정에서 데이터가 많아질 수록 디스크 쪽을 사용할 가능성이 높으니 소트 버퍼의 크기가 크면 좋을 것 같지만 그렇지 않다.
그러한 이유는 두 가지로 설명을 할 수 있다.

1. 메모리의 소트 버퍼에서 정렬을 수행하더라도 결과를 임시로 디스크에 저장을 하고 다음 레코드를 가져와 정렬하는
   행위를 반복하기 때문이다. 이러한 과정을 멀티 머지라하며 멀티 머지 횟수는 Sort_merge_passes라는 상태 변수에 누적돼 집계된다.
2. 메모리가 지나치게 할당되면 운영체제가 프로세스를 강제종료할 수 있다. 소트 버퍼 설정은 여러 클라이언트가 공유해서 설정되는
   부분이다. 그런데, 운영체제는 메모리 부족 현상을 겪으면 메모리 확보를 위해 메모리를 가장 많이 쓰는 프로세스를 강제종료한다.
   당연히 메모리를 많이 쓰는 MySQL이 1순위이기 때문에 소트 버퍼의 크기를 무작정 키우는 건 좋지 않다.

그래서, Real MySQL에서는 대량 데이터 정렬이 필요한 경우 대량 데이터 정렬이 일어나는 세션만 소트 버퍼의 크기를
조정하여 처리하고 글로벌 설정은 크기를 작게 설정하는 것을 권장한다.

---

## 정렬 처리 방법

쿼리에 ORDER BY가 사용되면 3가지 방법 중 하나로 정렬이 처리된다. 아래의 표에서 아래로 갈 수록 처리 속도가 느려진다.

|          정렬 처리 방법          |             실행 계획의 Extra 칼럼 내용              |
|:--------------------------:|:-------------------------------------------:|
|        인덱스를 사용한 정렬         | 별도 표기 없음 |
|     조인에서 드라이빙 테이블만 정렬      | "Using filesort" 메시지가 표시됨 |
| 조인에서 조인 결과를 임시 테이블로 저장후 정렬 | "Using temporary; Using filesort" 메시지가 표시됨 |

인덱스를 사용할 수 있다면 별도의 "Filesort" 과정이 필요없으니 인덱스를 순서대로 읽어 결과를 반환할 수 있다. 하지만
인덱스를 쓸 수 없다면 WHERE 조건에 일치하는 레코드를 정렬 버퍼에 저장해 정 처리를 한다. 인덱스를 쓸 수 없을 때 방식은 두 가지로 분류된다.

- 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬 수행

### 인덱스를 이용한 정렬
인덱스를 정렬에 쓰기 위해선 ORDER BY에 명시된 칼럼이 먼저 읽는 테이블에 속하고, ORDER BY 순서대로 생성된 인덱스가 필요하다.
또한 WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.

인덱스를 사용하면 실제 인덱스의 값이 정렬이 돼 있어 인덱스의 순서대로 읽기만 하면 된다. 그래서, 별도의 추가 작업이 없다.

※ 인덱스와 ORDER BY 절에서의 주의사항

ORDER BY가 부가적인 작업이 일어날 수 있으니, 인덱스를 탈 거라 기대하고 넣지 않는 경우가 있다. 
이는 데이터 특성의 변화에 따라 실행 계획이 바뀌면 버그로 이어질 수 있으니 생략해서는 안된다. 인덱스는 어차피
부가적인 ORDER BY를 위한 정렬처리를 안하니 성능 문제가 발생하지 않기 때문이다.

### 조인의 드라이빙 테이블만 정렬
조인을 하면 결과 레코드가 급격하게 불어난다. 그래서 조인이 일어나기 전에 첫 번쨰 테이블의 레코드를 정렬한 뒤 레코드를 줄여서
처리하면 데이터를 최소화할 수 있다. 이를 통해 인덱스가 걸리지 않은 경우에도 적은 메모리로 정렬된 데이터를 얻을 수 있다.

대신 이 방법에서는 첫 번째로 읽히는 테이블의 컬럼만으로 ORDER BY 절을 작성해야 한다.

```SQL
SELECT * FROM employees e, salaries s 
         WHERE s.emp_no = e.emp_no
         AND e.emp_no BETWEEN 100002 AND 100010
         ORDER BY e.last_name;
```

위의 구문은 WHERE 절에 PK로 된 값인 emp_no로 선택할 레코드를 크게 줄일 수 있고, 두 테이블 사이를 emp_no라는 인덱스로
가지고 올 수 있기 때문에 employee 테이블을 드라이빙 테이블로 설정한다. 단, 주의사항이 검색으로 값을 좁히는 용으로는 인덱스를 쓸 수 있지만,
인덱스를 통해서 정렬을 하는 것은 불가능하다.

위의 상황은 지금 드라이빙 테이블로 선택된 employee 테이블 컬럼에 해당하는 필드인 last_name만을 통해 정렬하므로 인덱스 레인지 스캔으로 값을 가져오고
last_name 필드로 정렬을 메모리 내에서 수행하고 조인을 하는 방식으로 동작을 하게 된다.

### 임시테이블을 이용한 정렬 방식
하나의 테이블을 조회해 정렬한다면 임시 테이블이 필요없지만 서브쿼리나 여러 테이블을 조인해서 결과를 정렬해야 하는 경우엔 임시 테이블이 필요하다.

이 방법은 정렬할 레코드가 가장 많기에 가장 느린 방법이다. 이번엔 앞의 예제와 다르게 ORDER BY를 드라이빙 테이블로 선택 가능한 employee가 아닌
드리븐 테이블에 존재하는 s.salary로 ORDER BY를 하는 경우를 살펴보자.

```SQL
SELECT * FROM employees e, salaries s 
         WHERE s.emp_no=e.emp_no
         AND e.emp_no BETWEEN 100002 AND 100010
         ORDER BY s.salary;
```

이 경우엔 일단 조인된 결과를 임시테이블로 저장하고 임시 테이블로 정렬을 하는 방식으로 동작하며 실행 계획 확인 시
"Using temporary: Using filesort"라는 코멘트가 표시된다.

※ 이해 확인용 예제

```SQL
SELECT * FROM tb_test1 t1, tb_test2 t2
         WHERE t1.col1 = t2.col1
         ORDER BY t1.col2
         LIMIT 10;
```

지금 위의 쿼리는 드라이빙 테이블이 어떤 거로 선정되냐와 정렬 방법에 따라 읽는 건수, 조인 횟수, 정렬해야 할 대상 건수가 달라진다.
tb_test1 테이블의 레코드가 100건이고, tb_test2 테이블의 레코드가 1000건(tb_test1의 레코드 1건 당, tb_test2의 레코드가 10개씩)
있다고 생각하고 표 값을 예상해보자.

tb_test1이 드라이빙 되는 경우

|      정렬 방법       |             읽어야 할 건수              | 조인 횟수 | 정렬해야 할 대상 건수 |
|:----------------:|:---------------------------------:|:-----:|:------------:|
|      인덱스 사용      |   tb_test1: 1건<br>tb_test2: 10건   |  1번   |      0건      |
| 조인의 드라이빙 테이블만 정렬 |  tb_test1: 100건<br>tb_test2: 10건  |  1번   |     100건     |
|  임시 테이블 사용 후 정렬  | tb_test1: 100건<br>tb_test2: 1000건 | 100번  |    1000건     |


tb_test2이 드라이빙 되는 경우

|      정렬 방법       |             읽어야 할 건수              | 조인 횟수 | 정렬해야 할 대상 건수 |
|:----------------:|:---------------------------------:|:-----:|:------------:|
|      인덱스 사용      |  tb_test2: 10건<br>tb_test2: 10건   |  10번  |      0건      |
| 조인의 드라이빙 테이블만 정렬 | tb_test2: 1000건<br>tb_test1: 10건  |  10번  |    1000건     |
|  임시 테이블 사용 후 정렬  | tb_test2: 1000건<br>tb_test2: 100건 | 1000번 |    1000건     |

정렬에 있어서 인덱스 설정도 중요하지만 어떤 드라이빙 테이블을 선택하게 하냐도 중요함을 알 수 있다. 또한, Filesort 작업을 거치는
쿼리는 LIMIT 조건이 크게 도움이 안됨을 기억하자.

---

## 정렬 처리 방법의 성능 비교
웹 서비스에서는 봍오 ORDER BY와 함께 LIMIT이 사용이 같이 된다. 하지만, ORDER BY나 GROUP BY 같은 작업은 주어진 조건을
만족하는 레코드를 모두 가져와 정렬을 수행하거나 GROUPING을 해야 LIMIT으로 건수를 제한할 수 있으므로 인덱스를 잘 걸더라도
ORDER BY나 GROUP BY에 의한 성능 저하가 일어날 수 있다.

### 스트리밍 방식
서버 쪽에서 처리할 데이터가 얼마인지 관계없이 조건에 만족하는 레코드가 검색될 떄마다 즉시 클라이언트에게 반환하는 방식이다.
이런 방식으로 동작을 하면 빠른 응답 시간을 보장해줄 수 있다.

### 버퍼링 방식
MySQL 서버에서 모든 레코드를 검색하고 정렬 작업을 하는 동안엔 클라이언트는 아무것도 하지 않고 기다려야 하기에 응답 속도가 느려진다.
결국 버퍼링 방식으로 처리되는 것은 결과를 모아 가공해야 응답이 가능하므로 LIMIT을 걸더라도 성능이 크게 바뀌지 않을 가능성이 높다.

참고로 JDBC는 응답 결과를 모두 받을 때까지 대기하며 MySQL에서 스트리밍 방식으로 보내는 데이터를 모아서 한번에 보내는 방식으로 동작한다.
이 방법은 불필요한 네트워크를 줄이고 서버 통신에서의 불필요한 자원 소모를 없앨 수 있다고 한다. 설정을 통해 MySQL과 JDBC 간 전송 방식을
스트리밍 방식으로 변경도 가능은 하다.

---

