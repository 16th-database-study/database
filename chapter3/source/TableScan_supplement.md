# 풀테이블 스캔 
MySQL 옵티마이저가 풀테이블스캔을 선택하는 경우 예시

- 테이블 레코드 건수가 너무 작아 인덱스보단 풀 테이블 스캔을 하는 게 빠른 경우
- WHERE 절이나 ON 절에 적절한 인덱스를 이용할 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있더라도 일치하는 레코드 건수가 많아 옵티마이저가 효율이 떨어진다 생각하는 경우

※ 풀테이블 스캔과 인덱스 풀 스캔에서의 리드 어헤드 작업

풀테이블 스캔은 실행 시 여러 블록이나 페이지를 읽어오는 기능을 내장하고 있다.
InnoDB 스토리지 엔진을 기준으로 초기에 데이터를 읽을 땐 포어그라운드 쓰레드에서 초기 데이터를 읽는다.

하지만, 어느정도 포어그라운드에서 작업이 이뤄지면 리드 어헤드라는 작업이 일어난다.
리드어헤드는 앞으로 어떤 데이터가 필요해질 것이라 예측해 미리 백그라운드 스레드에 의해 디스크에서 데이터를 읽어 버퍼 풀에 가져다 두는 작업인데,
읽기가 진행됨에 따라 점점 한번에 읽는 페이지를 증가시키는 특성이 있다.

이러한 이유로 풀테이블 스캔 시에 빠르게 데이터 처리가 일어날 수 있게 되는데, 직접 풀 테이블 스캔 때 읽어오는
페이지 수는 조절할 수 없지만 리드 어헤드 작업의 임계값 변화를 통해 어느정도 튜닝이 가능하다.

```SQL
innodb_read_ahead_threshold
```

또한, 인덱스 풀 스캔 뿐만 아니라 인덱스 풀 스캔에서도 리드 어헤드 작업이 이뤄진다.

---

## 인덱스 풀 스캔
사실 풀 테이블 스캔과 인덱스 레인지 스캔을 제외하고는 자주 일어나는 작업은 아니다. 인덱스 풀 스캔은 
잘 일어나지 않는 작업인데, 인덱스 풀 스캔을 통해 가장 크게 이득을 볼 수 있는 건 COUNT 쿼리이다.

COUNT 쿼리의 경우에는 레코드 건수만 필요하기 때문에 풀 테이블 스캔으로 모든 데이터를 가져오면 모든 컬럼 데이터를
가지고 있기에 페이지 당 가져오는 레코드가 적다. 하지만,세컨더리 인덱스를 통해서 인덱스 값으로만 데이터를 거를 수 있으면 
한 블록 당 가져올 수 있는 데이터가 더 크다. 

그렇기 때문에 COUNT 쿼리가 인덱스 풀 스캔을 자주 고르는 예시 중에 하나라고 한다. 나머지도 사실 거의 특수한 경우라 생략해도 괜찮지 않을까 싶다.

---
