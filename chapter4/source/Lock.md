# Lock
> MySQL에서 사용되는 잠금은 크게 MySQL 엔진 레벨과 스토리지 엔진 레벨로 나눌 수 있다.

## 1. MySQL 엔진의 잠금
MySQL 엔진 레벨의 잠금은 모든 스토리지에 영향을 미친다.

### (1) 글로벌 락
- `FLUSH TABLES WITH READ LOCK` 명령으로 획득하며, `UNLOCK TABLES` 명령으로 해제한다.
- 한 세션에서 글로벌 락을 획득하면, 다른 세션에서 SELECT를 제외한 대부분의 DDL, DML 쿼리를 실행하려는 경우 글로벌 락이 해제될 때까지 대기 상태로 남는다.
- 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때는 글로벌 락을 사용해야 한다.
- 하지만, 해당 락은 MySQL 전체에 영향을 미친다.(MySQL에서 제공하는 잠금 증 가장 범위가 크다.) 따라서, 웹 서비스의 경우 가급적 사용하지 않는 것이 좋다.


### (cf) 백업 락
- MySQL 8.0 버전 부터 InnoDB가 기본 엔진으로 채택되면서 가벼운 글로벌락의 필요성 때문에 추가되었다.
- 특정 세션에서 백업 락을 획득하면 다음과 같은 정보를 변경할 수 없다.

  - 데이터베이스 및 테이블 등 모든 객체 생성, 변경, 삭제
  - REPAIR TABLE과 OPTIMIZE TABLE 명령
  - 사용자 관리 및 비밀번호 변경

- 일반적인 MySQL 서버 구성은 소스 서버와 레플리카 서버로 구성되는데, 주로 백업은 레플리카 서버에서 실행되는데, 이때 백업 락을 사용해 백업이 정상적으로 이루어지도록 하는 역할을 한다. 


### (2) 테이블 락
> 개별 테이블 단위로 설정되는 잠금으로, 명시적 또는 묵시적으로 특정 테이블 락을 획득할 수 있다.

- **명시적인 테이블 락**

  - `LOCK TABLES table_name [READ | WRITE]` 명령으로 획득하며, `UNLOCK TABLES` 명령으로 해제한다.
  - 명시적 테이블 락은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문에 특별한 상황이 아니라면 애플리케이션에서 사용하는 경우가 거의 없다.


- **묵시적인 테이블 락**

  - MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제하는 형태로 사용한다.
  - 즉, 쿼리가 실행되는 동안 자동으로 획득했다가 쿼리가 완료되면 자동으로 해제된다.
  - 하지만 InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 테이블 변경 쿼리로 인해 묵시적 락이 설정되지 않는다. (더 정확히 말하자면, DML 쿼리에서는 무시되고 스키마 변경의 DDL 쿼리의 경우에만 영향을 미친다.)


### (3) 네임드 락
- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
- 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 해제하는 잠금이다.
- 네임드 락은 자주 사용하지 않는다.
- 하지만, 다음과 같은 특정 상황에서 네임드 락을 사용하면 상황을 쉽게 해결할 수 있다.

  1. 여러 클라이언트가 상호 동기화를 처리해야 할 때
  2. 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에서

- 2번의 경우, 한꺼번에 많은 레코드를 변경하는 쿼리는 데드락의 원인이 된다. 이러한 경우 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있다.
- MySQL 8.0 버전부터 네임드 락을 중첩해서 사용할 수 있으며, 현재 세션에서 획득한 네임드 락을 한 번에 모두 해제하는 기능도 추가됐다.


### (4) 메타데이터 락
- 데이터베이스 객체(테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우 획득하는 잠금이다.
- 명시적으로 획득하거나 해제할 수 있는 것이 아니고, "RENAME TABLE tab_a TO tab_b"와 같이 테이블 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

```sql
// 1. 각각의 문장으로 실행하는 경우
RENAME TABLE rank TO rank_backup;
RENAME TABLE rank_new TO rank;

// 2. 하나의 문장으로 실행하는 경우
RENAME TABLE rank TO rank_backup, rank_new TO rank;
```

- 위의 예시에서 1번의 경우 짧은 시간이지만 rank 테이블이 존재하지 않는 순간이 생겨 `Table not found 'rank'` 오류가 발생되지만, 2번의 경우에는 오류 없이 적용된다.


## 2. InnoDB 스토리지 엔진의 잠금
스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

### (1) 레코드 락
- InnoDB 스토리 엔진의 레코드 락은 레코드 자체가 아니라 인덱스의 레코드를 잠그는 락이다.
- 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 사용한다.
- 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 레코드 자체에 대해서만 락을 건다.


### (2) 갭 락
- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만 잠근다.
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 막기 위해 사용한다.
- 갭락 자체보다는 넥스트 키락의 일부로 사용한다.


### (3) 넥스트 키 락
- 레코드 락과 갭 락을 합쳐놓은 형태의 잠금이다.
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장한다.
- 하지만, 넥스트 키 락과 갭락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리는 일이 자주 발생할 수 있으므로 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.


### (4) 자동 증가 락
- AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT되는 경우, 각 레코드는 순서대로 증가하는 일련번호 값을 가져야 하는데, 이를 위해 자동 증가 락을 사용한다.
- 트랜잭션과 관계 없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 즉시 락을 걸었다가 해제한다. (명시적으로 획득하고 해제할 수 없다.)
- MySQL 5.1 이상부터는 `innodb_autoinc_lock_mod` 라는 시스템 변수를 활용해 자동증가락의 작동 방식을 변경할 수 있다.
- 자동 증가 락이 한 번 증가하면 절대 값이 줄어들지 않는다. 따라서, INSERT 쿼리가 실패하도 한 번 증가한 값은 그대로 남는다.
- 대량의 데이터를 INSERT 할 경우, 스토리지 엔진은 여러 개의 자동 증가 락을 한 번에 할당 받는다. 이때 자동 증가 락이 사용되지 않고 남게 되면 폐기되므로 이후 실행되는 쿼리의 자동 증가 값은 연속되지 않을 수 있다.
