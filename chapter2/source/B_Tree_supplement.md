## 체인지 버퍼

RDBMS에서 데이터를 변경하면 데이터 파일 변경 뿐 아니라 인덱스를 업데이트하는 작업이 발생한다. 인덱스 업데이터는 랜덤 I/O 작업이 요구되기 때문에 자원을 많이 사용하게 된다. 인덱스가 버퍼풀에 있으면 바로 업데이트하고 사용자에게 결과를 반환하면 된다. 하지만 디스크에 있다면 이를 읽어와서 변경해야 하기 때문에 변경 사항을 임시 공간에 저장해두는데 이 공간을 **체인지 버퍼**라고 한다.

### 버퍼 사이즈

기본값은 InnoDB 버퍼풀 메모리의 25%를 사용하고 최대 50%까지 사용할 수 있다.

-> 쓰기 연산이 상대적으로 많아서 인덱스 업데이트 비율이 높다면 체인지 버퍼 크기를 늘리고 아니라면 줄이면 될 것 같다.

### 주의 사항

사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 **유니크 인덱스**, **PK**는 체인지 버퍼를 사용할 수 없고 즉시 인덱스 업데이트가 수행된다.



## 인덱스

### 인덱스 키 값의 크기는 가능한 작게 설계하기

InnoDB 기본 페이지 크기 : 16KB (설정 가능)

* 인덱스 키의 크기 : 16 byte
* 자식 노드 주소 크기 : 12 byte
* 하나의 페이지에 담길 수 있는 키의 개수 = 16 * 1024 / (16 + 12) = 585개
  * 단위 : byte

이 경우 자식 노드를 585개 가질 수 있다. 설명에서 2억개의 레코드를 삽입한다고 할 때, B-Tree를 사용하는 경우 585 * 585 * 585 ≈ 2억 이므로 깊이 3으로 저장 가능하다. 

위의 가정과 동일한데 인덱스의 크기만 32 byte로 늘어난다고 해보자. 

* 인덱스 키의 크기 : 32 byte
* 자식 노드 주소 크기 : 12 byte
* 하나의 페이지에 담길 수 있는 키의 개수 = 16 * 1024 / (32 + 12) = 372개

16byte 일 때는 585개를 담을 수 있었는데 32byte가 되면서 372개 밖에 담을 수 없게 됐다. 만약 SELECT로 레코드 500개를 읽는다면 전자는 인덱스 페이지 한번으로 처리 가능하지만 후잔느 2번 이상 디스크로부터 데이터를 읽어야 한다.

-> 인덱스 키 값이 커질수록 디스크 I/O 횟수가 증가한다.